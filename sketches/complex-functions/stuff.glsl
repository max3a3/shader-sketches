// The input is a complex number with the x-axis as the real
// part and the y-axis as the imaginary part.
//
// The output number is displayed by a color where
// hue is the argument and the brightness is the magnitude.

// -----------------------------------------------------------

// Constants
const float pi = 3.14159265359;
const float pi2 = 2.0 * 3.14159265359;
const float piD3 = 3.14159265359 / 3.0;

// -----------------------------------------------------------

// Viewport

// X scale
const float Xs = 3.0;
// X offset
const float Xo = 0.0;
// Y scale
const float Ys = 2.0;
// Y offset
const float Yo = 0.0;

const mat3 view = mat3
(
	Xs ,0.0,Xo,
    0.0,Ys ,Yo,
    0.0,0.0,1.0
);

// -----------------------------------------------------------

// Math operations for complex numbers

vec2 CxMul(vec2 a, vec2 b)
{
    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);
}

vec2 CxSquare(vec2 a)
{
    return vec2(a.x*a.x - a.y*a.y, 2.0*a.x*a.y);
}

vec2 CxCon(vec2 a)
{
    return vec2(a.x,-a.y);
}

float CxAbs(vec2 a)
{
    return sqrt(dot(a,a));
}

float CxPhase(vec2 a)
{
    return mod(atan(a.y,a.x),pi2);
}

vec2 CxPolarize(vec2 a)
{
    return vec2(CxPhase(a),CxAbs(a));
}

vec2 CxDiv(vec2 a, vec2 b)
{
    return CxMul(a,CxCon(b))/dot(b,b);
}

vec2 CxExp(vec2 a)
{
    return exp(a.x)*vec2(cos(a.y),sin(a.y));
}

vec2 CxLog(vec2 a)
{
    a = CxPolarize(a);
    return vec2(log(a.y),a.x);
}

vec2 CxPow(vec2 a, vec2 b)
{
    return CxExp(CxMul(CxLog(a),b));
}

// -----------------------------------------------------------

// Engine

vec3 h1(float h)
{
    return vec3
    (
        clamp(abs(3.0-h/piD3) - 1.0,0.0,1.0),
        clamp(2.0 - abs(2.0-h/piD3),0.0,1.0),
        clamp(2.0 - abs(4.0-h/piD3),0.0,1.0)
    );
}

vec3 h2(float h)
{
    return vec3
    (
        (1.0 + cos(h))/2.0,
        (1.0 + cos(h - 2.0*piD3))/2.0,
        (1.0 + cos(h - 4.0*piD3))/2.0
    );
}

vec3 v1(vec3 a, float v)
{
    a *= 1.0 - abs(2.0*v-1.0);

    if(v > 0.5) a += vec3(2.0*v - 1.0);

    return clamp(a,0.0,1.0);
}

vec3 v2(vec3 a,float v)
{
    vec3 r = vec3(v*v);
    r-= 2.0*v*(v-1.0)*a;
    return r;
}

// Color from hue and value
vec3 Color(float h,float v)
{
    // H gives a color from hue
    // H1 is sharper
    // H2 is smoother
    vec3 a = h2(h);

    // V modifies the brightness off a color generated by H
    // V1 is sharper
    // V2 is smoother
    return v1(a,v);
}

vec3 ComplexColor(vec2 a)
{
    a = CxPolarize(a);
    return Color(a.x,1.0 - 1.0/(1.0 + a.y));
}

// Gets mouse coordinates
vec2 m()
{
    vec2 M = 2.0*(iMouse.xy/iResolution.xy-0.5);
    return (vec3(M,1.0) * view).xy;

}

// -----------------------------------------------------------


// This is the function used for plotting.
// Feel free to change it.
vec2 f(vec2 x)
{
    vec2 x2 = x-m();
    vec2 x3 = x-vec2(cos(iTime), sin(iTime)*cos(iTime));

    vec2 v = CxDiv(x3,x2) * CxMul(x3,x2);
    return CxMul(x,v);
}


void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = fragCoord/iResolution.xy;
    uv -= 0.5;
    uv *= 2.0;
    uv = (vec3(uv,1.0) * view).xy;

    vec2 p = f(uv);

    vec3 col = ComplexColor(p);

    vec2 dr = CxPolarize(p);
    vec2 dc = smoothstep(2.*0.01,0.01,dr);
    float val = dot(dc, vec2(1));
    col = .5 + .47*cos(6.2831*val + vec3(0, 1, 2));

    // Output to screen
    fragColor = vec4(col,1.0);
}